\section{Algorithm}

In this section we discuss the layout optimization algorithm.

\subsection{Layout Language}

Our layout language is a language of nested structures which subsumes standard
database layouts such as row and column stores and allows for an efficient
implementation.
The layout language is designed to work with the relational algebra so that
queries can be written over specialized layouts.
The layout language can compactly represent the results of executing common
relational algebra operations, so query processing can be replaced by data
layout.
This allows queries to be incrementally rewritten using semantics preserving
transformations, as described in Section~\ref{sec:rules}.

\subsubsection{Syntax}

\begin{figure}
  \begin{align*}
    v,\ k\ &::=\ \text{<primitive value>} \\
    f\ &::=\ \text{<field>} \\
    o\ &::=\ \text{Asc}\ |\ \text{Desc} \\
    L\ &::=\ \emptyset \\
           &|\ \text{Value}\ v \\
           &|\ \text{UnorderedList}\ [L_1,\ \dots,\ L_n] \\
           &|\ \text{OrderedList}\ o\ f\ [L_1,\ \dots,\ L_n] \\
           &|\ \text{CrossTuple}\ [L_1,\ \dots,\ L_n] \\
           &|\ \text{ZipTuple}\ [L_1,\ \dots,\ L_n] \\
           &|\ \text{Table}\ f\ \{k_1 \mapsto L_1,\ \dots,\ k_1 \mapsto L_1\}\\
    R\ &::=\ L\ |\ \pi_F R\ |\ \sigma_\phi R\ |\ \bowtie_\phi R_1 R_2\ |\ g_{F,a} R\ |\ R_1 \concat R_2
  \end{align*}
  \caption{Syntax of the layout language.}
\end{figure}

\subsubsection{Semantics}

A layout can be evaluated, yielding a stream of tuples. Evaluation occurs in a
context which binds the

\begin{figure}
  \[
    \inference[E-Emp]{}{\Gamma |- \emptyset => [\ ]}
    \inference[E-Val]{}{\Gamma |- \text{Value}\ v => [(v)]}
  \]
  \[
    \inference[E-UL]{\Gamma |- L_1 => s_1, \dots, \Gamma |- L_n => s_n}{\Gamma |- \text{UnorderedList}\ [L_1,\ \dots,\ L_n] =>
      s_1 \concat \dots \concat s_n}
  \]
  \[
    \inference[E-OL]{\Gamma |- L_1 => s_1, \dots, \Gamma |- L_n => s_n}{\Gamma |- \text{OrderedList}\ [L_1,\ \dots,\ L_n] =>
      s_1 \concat \dots \concat s_n}
  \]
  \[
    \inference[E-CT1]{\Gamma |- L => s}{\Gamma |- \text{CrossTuple}\ [L] =>
      s}
  \]
  \[
    \inference[E-CT2]{\Gamma |- L => s_l,\ \Gamma |- \text{CrossTuple}\ LS => s_{ls}}{\Gamma |- \text{CrossTuple}\ (L:LS) =>
      s_l \times s_{ls}}
  \]
  \[
    \inference[E-ZT]{\Gamma |- L_1 => s_1, \dots, \Gamma |- L_n => s_n & |s_1| =
    \dots = |s_n|}{
      \begin{array}{c}
        \Gamma |- \text{ZipTuple}\ [L_1,\ \dots,\ L_n] => \\
        {[t_1\concat \dots \concat t_n\ |\ t_1 \leftarrow s_1, \dots, t_n \leftarrow s_n]}
      \end{array}
    }
  \]
  \[
    \inference[E-T]{m[\Gamma[f]] = L & \Gamma |- L => s}{
      \Gamma |- \text{Table}\ f\ m => s
    }
  \]
  \caption{Semantics of the layout language.}
\end{figure}

The semantics of the relational algebra are standard.
The stream of tuples produced by scanning a layout can be treated in the same
way that a scan over a standard database is.

\subsection{Equivalence Rules}
\label{sec:rules}

We define a set of equivalence relations between relational algebra expressions.
These relations allow us to transform a query and the layout that it operates on
simultaneously.
These equivalence rules rely on layout transformation functions.
For example, \texttt{partition} transforms a layout containing a field $f$ into
a Table with $f$ as the key field.

\begin{figure}
  \begin{align}
    \sigma_{\phi \land \psi}\ q &\equiv \sigma_\psi\ \sigma_\phi\ q \tag{EQ-And1} \\
    \sigma_{\phi \land \psi}\ q &\equiv \sigma_\phi\ \sigma_\psi \ q \tag{EQ-And2} \\
    \sigma_{\phi \lor \psi}\ q &\equiv \sigma_\phi q \concat \sigma_\psi\ q \tag{EQ-Or} \\
    \sigma_{f = x}\ L &\equiv \texttt{partition}\ f\ L \tag{EQ-Eq} \\
    \sigma_{f \geq x}\ L &\equiv \texttt{order}\ f\ L \tag{EQ-Ge} \\
    \bowtie_{f_1 = f_2}\ L_1\ L_2 &\equiv \sigma_{f_1 = f_2} (\text{CrossTuple}\ [L_1, L_2]) \tag{EQ-EqJoin} \\
    \pi_F\ L &\equiv \texttt{project}\ F\ L \tag{EQ-Proj} \\
    L_1 \concat L_2 &\equiv \text{UnorderedList}\ [L_1, L_2] \tag{Eq-Concat}
  \end{align}
  \caption{Equivalence relations between queries.}
\end{figure}


\subsection{Synthesis Algorithm}

To find the best layout for a query, we use the equivalence rules to find the
set of equivalent queries.
We measure the cost of each equivalent query and select the query with the
lowest cost.

\begin{algorithm}
  \begin{algorithmic}
    \Require{$q$ is a relational algebra expression. $R$ is a collection of equivalence rules.}
    \Function{Synthesize}{$q, R$}
    \State $P \gets \{q\}$
    \Loop
    \State $P' = \emptyset$
    \For{$r \in R$}
    \If{$r$ matches $q$}
    \State $P' = P' \cup \{ r(q') ~|~ q' \in P \}$
    \EndIf
    \EndFor
    \If{$P = P'$}
    \State \Return $P$
    \Else
    \State $P \gets P'$
    \EndIf
    \EndLoop
    \EndFunction
  \end{algorithmic}
  \caption{Create a set of candidate programs by taking the fixpoint of the
    equivalence rules.}
\end{algorithm}

\subsection{Cost Model}
  
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
